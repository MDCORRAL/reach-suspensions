<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Tail Concentration Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  <style>
    :root {
      color-scheme: light;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      --bg: #daebfe;
      --card-bg: #ffffff;
      --border: #8bb8e8;
      --text: #003b5c;
      --muted: rgba(0, 59, 92, 0.8);
      --accent: #2774ae;
      --accent-strong: #005587;
      --accent-soft: #8bb8e8;
      --highlight: #ffb81c;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
    }

    header {
      background: var(--accent-strong);
      color: #ffffff;
      padding: 2.5rem 1.5rem 2rem;
      box-shadow: 0 4px 18px rgba(0, 59, 92, 0.35);
    }

    .header-top {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .methodology-button {
      margin-left: auto;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      border: none;
      background: var(--highlight);
      color: var(--accent-strong);
      font-weight: 600;
      padding: 0.55rem 1.1rem;
      border-radius: 999px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      text-decoration: none;
    }

    .methodology-button:hover {
      background: #ffc85b;
      box-shadow: 0 8px 18px rgba(0, 59, 92, 0.25);
      transform: translateY(-1px);
    }

    .methodology-button:focus-visible {
      outline: 2px solid #ffd277;
      outline-offset: 3px;
      box-shadow: 0 0 0 4px rgba(255, 184, 28, 0.35);
    }

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.95rem;
      font-weight: 600;
      color: rgba(218, 235, 254, 0.95);
      text-decoration: none;
      padding: 0.45rem 0.85rem;
      border-radius: 999px;
      background: rgba(0, 59, 92, 0.35);
      transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
    }

    .back-link:hover {
      background: rgba(0, 59, 92, 0.55);
      color: #ffffff;
      transform: translateX(-2px);
    }

    .back-link:focus-visible {
      outline: 2px solid var(--highlight);
      outline-offset: 3px;
      box-shadow: 0 0 0 4px rgba(255, 184, 28, 0.3);
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.8rem, 3vw, 2.4rem);
      letter-spacing: -0.01em;
    }

    header p {
      margin: 0.75rem 0 0;
      max-width: 60rem;
      font-size: 1rem;
      color: rgba(218, 235, 254, 0.85);
    }

    main {
      padding: 1.5rem;
      max-width: 1200px;
      margin: 0 auto 4rem;
    }

    .card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 10px 22px rgba(0, 59, 92, 0.1);
    }

    h2 {
      margin-top: 0;
      font-size: 1.35rem;
    }

    h3 {
      margin-top: 0;
      font-size: 1.1rem;
      color: var(--muted);
    }

    #controls {
      display: grid;
      gap: 1rem;
    }

    @media (min-width: 768px) {
      #controls {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    @media (max-width: 600px) {
      .header-top {
        flex-wrap: wrap;
        margin-bottom: 1.25rem;
      }

      .back-link {
        font-size: 0.9rem;
        padding: 0.4rem 0.75rem;
      }

      .methodology-button {
        margin-left: 0;
        width: 100%;
        justify-content: center;
      }
    }

    label {
      display: flex;
      flex-direction: column;
      font-size: 0.9rem;
      gap: 0.45rem;
      font-weight: 600;
      color: var(--muted);
    }

    select {
      border-radius: 10px;
      border: 1px solid var(--border);
      padding: 0.55rem 0.75rem;
      font-size: 0.95rem;
      font-family: inherit;
      background: var(--card-bg);
      color: var(--text);
      outline: none;
    }

    select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(39, 116, 174, 0.3);
    }

    .note {
      margin-top: 0.75rem;
      font-size: 0.88rem;
      color: var(--muted);
    }

    .summary {
      font-size: 0.95rem;
      margin-bottom: 1rem;
      color: var(--muted);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }

    thead {
      background: var(--accent-soft);
      color: var(--text);
    }

    th, td {
      padding: 0.6rem 0.75rem;
      border-bottom: 1px solid var(--border);
      text-align: left;
    }

    td.statement {
      max-width: 28rem;
      white-space: normal;
      line-height: 1.35;
    }

    tbody tr:last-child td {
      border-bottom: none;
    }

    .empty {
      padding: 1rem;
      background: rgba(218, 235, 254, 0.75);
      border-radius: 12px;
      border: 1px dashed var(--border);
      text-align: center;
      color: var(--muted);
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-top: 0.75rem;
    }

    .button-row button {
      border-radius: 999px;
      border: none;
      padding: 0.5rem 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.2s ease, color 0.2s ease;
    }

    button.reset {
      background: var(--accent-soft);
      color: var(--text);
    }

    button.reset:hover {
      background: var(--accent);
      color: #ffffff;
    }


    #download-csv {
      background: var(--accent);
      color: #ffffff;
    }

    #download-csv:hover:not(:disabled) {
      background: var(--accent-strong);
    }

    #download-csv:disabled {
      background: var(--border);
      color: var(--muted);
      cursor: not-allowed;
    }

    #loading {
      text-align: center;
      padding: 4rem 1rem;
      font-size: 1.05rem;
      color: var(--muted);
    }

    .info-card h3 {
      font-size: 1rem;
      color: var(--accent-strong);
      text-transform: uppercase;
      letter-spacing: 0.04em;
      margin-bottom: 0.25rem;
    }

    .info-card section + section {
      margin-top: 1.25rem;
      padding-top: 1rem;
      border-top: 1px solid rgba(0, 59, 92, 0.15);
    }

    .info-card ul {
      margin: 0.35rem 0 0.75rem;
      padding-left: 1.25rem;
      font-size: 0.95rem;
      line-height: 1.55;
    }

    .info-card p {
      font-size: 0.95rem;
      line-height: 1.55;
      margin: 0.35rem 0 0.75rem;
    }

    .info-links {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-top: 1.5rem;
    }

    .info-links a {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      background: var(--accent);
      color: #ffffff;
      padding: 0.5rem 1rem;
      border-radius: 999px;
      text-decoration: none;
      font-weight: 600;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .info-links a:hover {
      background: var(--accent-strong);
      transform: translateY(-1px);
    }

    .info-links a:focus-visible {
      outline: 2px solid var(--highlight);
      outline-offset: 3px;
      box-shadow: 0 0 0 4px rgba(255, 184, 28, 0.4);
    }
  </style>
</head>
<body>
  <header>
    <div class="header-top">
      <a class="back-link" href="index.html">← Back to dashboard home</a>
      <a class="methodology-button" href="#methodology-and-filters">
        Methodology &amp; filters
      </a>
    </div>
    <h1>Tail Concentration Explorer</h1>
    <p>
      Use the controls below to surface the existing grade-setting outputs produced by the REACH suspension
      analyses. Toggle grade levels and school types to see the prepared results without running any new
      computations.
    </p>
  </header>
  <main>
    <div id="loading">Loading pre-computed data…</div>
    <section id="content" hidden>
      <div class="card">
        <h2>Filters</h2>
        <div id="controls"></div>
        <div class="button-row">
          <button type="button" id="download-csv" disabled>Download CSV</button>
          <button class="reset" type="button" id="reset-filters">Reset all filters</button>
        </div>
        <p class="note">
          The selections above simply filter the data that has already been generated by the grade-setting script.
          No additional analysis is performed when you make a selection.
        </p>
      </div>

      <section class="dashboard" aria-label="Tail concentration visuals">
        <article class="chart-container">
          <h3>Suspension share captured by top cohorts</h3>
          <p class="chart-description">
            Compare how much of the suspension count is concentrated among the top cohorts selected in the prepared
            grade-setting analysis.
          </p>
          <div class="chart-wrapper">
            <canvas id="top-share-chart" aria-label="Chart showing suspension share captured by top groups" role="img"></canvas>
          </div>
          <p class="chart-empty" data-chart-empty hidden>No chart data available for these filters.</p>
        </article>
        <article class="chart-container">
          <h3>Suspension concentration breakdown</h3>
          <p class="chart-description">
            Revisit how each cohort contributes to the total share of suspensions by reframing the same prepared values in
            a complementary donut view.
          </p>
          <div class="chart-wrapper">
            <canvas id="cohort-size-chart" aria-label="Chart showing suspension share contributed by each cohort" role="img"></canvas>
          </div>
          <p class="chart-empty" data-chart-empty hidden>No chart data available for these filters.</p>
        </article>

        <section class="card table-card" id="grade-setting-section">
          <h2>Grade level × school type summary</h2>
          <p class="summary" id="grade-summary"></p>
          <div id="grade-table-wrapper"></div>
        </section>
      </section>

      <section class="card info-card" id="methodology-and-filters" aria-labelledby="methodology-title">
        <h2 id="methodology-title">Methodology &amp; filters</h2>
        <section aria-labelledby="data-sources-heading">
          <h3 id="data-sources-heading">Data sources</h3>
          <p>
            Tail concentration metrics reuse the staged parquet files produced by the REACH pipeline. Suspension totals come
            from <code>susp_v*.parquet</code> files that include school-level counts, while <code>susp_v6_features.parquet</code>
            supplies school type and traditional vs. non-traditional tags used for grouping. Only records with valid
            enrollment and suspension counts are included.
          </p>
        </section>
        <section aria-labelledby="top-share-heading">
          <h3 id="top-share-heading">Top-share definitions</h3>
          <ul>
            <li>Schools are sorted within each academic year × level × setting group by total suspensions.</li>
            <li>The analysis reports what share of suspensions is captured by the top 5%, 10%, and 20% of schools in each group.</li>
            <li>Slide-ready statements shown in the table mirror the prepared CSV export from the grade-setting workflow.</li>
          </ul>
        </section>
        <section aria-labelledby="filter-behavior-heading">
          <h3 id="filter-behavior-heading">Filter behavior</h3>
          <ul>
            <li>The dropdowns surface pre-computed results; switching filters does not rerun any analysis.</li>
            <li>Academic year options are derived from the staged dataset and appear in ascending order.</li>
            <li>Resetting filters returns all dropdowns to “All” and repopulates the full prepared statement list.</li>
          </ul>
        </section>
        <div class="info-links" aria-label="Full documentation links">
          <a href="Analysis/data_processing_overview.md" target="_blank" rel="noopener">Read the data processing overview</a>
          <a href="Analysis/README_tail_concentration_by_level.md" target="_blank" rel="noopener">Read the tail concentration methodology</a>
        </div>
      </section>
    </section>
  </main>
  <script>
    (function () {
      'use strict';

      const DATA_URL = 'dashboard/pareto_grade_setting_payload.json';
      const DATA_BUNDLE_URL = 'dashboard/data/pareto_grade_setting_payload.js';

      const state = {
        academicYear: 'All',
        gradeLevel: 'All',
        schoolType: 'All',
      };

      const store = {
        rows: [],
        filtered: [],
        latestExport: [],
      };

      const charts = {
        topShare: null,
        concentration: null,
      };

      const DOM = {
        loading: document.getElementById('loading'),
        content: document.getElementById('content'),
        controls: document.getElementById('controls'),
        summary: document.getElementById('grade-summary'),
        tableWrapper: document.getElementById('grade-table-wrapper'),
        download: document.getElementById('download-csv'),
        reset: document.getElementById('reset-filters'),
      };

      const COLORS = ['#2774AE', '#FFB81C', '#8BB8E8', '#005587', '#FFC72C'];
      const REMAINDER_COLOR = 'rgba(39, 116, 174, 0.18)';
      const REMAINDER_HOVER = 'rgba(39, 116, 174, 0.32)';

      const formatters = {
        toAcademicYear(year) {
          if (typeof year !== 'number' || Number.isNaN(year)) return '';
          const next = String(year + 1).slice(-2);
          return `${year}-${next}`;
        },
        toYearNumber(label) {
          if (!label || label === 'All') return null;
          const match = String(label).match(/^(\d{4})/);
          return match ? Number(match[1]) : null;
        },
        integer(value) {
          return Number.isFinite(value) ? Math.round(value).toLocaleString() : '—';
        },
        percent(value) {
          return Number.isFinite(value) ? `${(value * 100).toFixed(1)}%` : '—';
        },
        share(value) {
          return Number.isFinite(value) ? `${value.toFixed(1)}%` : '—';
        },
      };

      function getPreloadedData() {
        if (typeof window === 'undefined') return null;
        const payload = window.TAIL_CONCENTRATION_DATA;
        if (payload && Array.isArray(payload.gradeSetting)) {
          return payload;
        }
        return null;
      }

      async function requestJson(url) {
        if (typeof fetch === 'function') {
          const response = await fetch(url, { cache: 'no-store' });
          if (!response.ok) {
            throw new Error(`Request failed with status ${response.status}`);
          }
          return response.json();
        }

        return new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', url, true);
          xhr.responseType = 'json';
          xhr.onload = () => {
            if (xhr.status >= 200 && xhr.status < 300) {
              resolve(xhr.response);
            } else {
              reject(new Error(`XHR request failed with status ${xhr.status}`));
            }
          };
          xhr.onerror = () => reject(new Error('XHR network error'));
          xhr.send();
        });
      }

      function ensureBundleLoaded() {
        const preloaded = getPreloadedData();
        if (preloaded) {
          return Promise.resolve(preloaded);
        }

        return new Promise((resolve, reject) => {
          const selector = 'script[data-tail-concentration-bundle]';
          let script = document.querySelector(selector);

          const resolveWithPayload = () => {
            const payload = getPreloadedData();
            if (payload) {
              resolve(payload);
            } else {
              reject(new Error('Fallback bundle loaded without payload.'));
            }
          };

          const handleError = () => {
            if (script && script.dataset) {
              script.dataset.bundleState = 'error';
            }
            reject(new Error('Failed to load fallback data bundle.'));
          };

          if (script) {
            const stateAttr = script.dataset ? script.dataset.bundleState : undefined;
            if (stateAttr === 'loaded') {
              resolveWithPayload();
              return;
            }
            if (stateAttr === 'error') {
              handleError();
              return;
            }
            script.addEventListener('load', resolveWithPayload, { once: true });
            script.addEventListener('error', handleError, { once: true });
            return;
          }

          script = document.createElement('script');
          script.src = DATA_BUNDLE_URL;
          script.dataset.tailConcentrationBundle = 'true';
          script.dataset.bundleState = 'loading';
          script.addEventListener('load', () => {
            script.dataset.bundleState = 'loaded';
            resolveWithPayload();
          }, { once: true });
          script.addEventListener('error', handleError, { once: true });
          document.head.appendChild(script);
        });
      }

      async function loadPreparedData() {
        const preloaded = getPreloadedData();
        if (preloaded) {
          return preloaded;
        }

        const resolvedUrl = (() => {
          try {
            return new URL(DATA_URL, window.location.href).toString();
          } catch (error) {
            return DATA_URL;
          }
        })();

        try {
          const payload = await requestJson(resolvedUrl);
          if (payload && Array.isArray(payload.gradeSetting)) {
            return payload;
          }
          console.warn('Prepared payload missing expected gradeSetting array.');
        } catch (error) {
          console.warn('Direct JSON request for prepared data failed:', error);
        }

        return ensureBundleLoaded();
      }

      function configureChartDefaults() {
        if (typeof Chart === 'undefined' || !Chart.defaults) return;
        const styles = getComputedStyle(document.documentElement);
        const fontFamily = styles.getPropertyValue('font-family')
          || "'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
        const textColor = styles.getPropertyValue('--text') || '#003b5c';
        Chart.defaults.font.family = fontFamily.trim();
        Chart.defaults.color = textColor.trim();
        Chart.defaults.plugins.legend.labels.usePointStyle = true;
        Chart.defaults.plugins.tooltip.backgroundColor = 'rgba(0, 59, 92, 0.9)';
      }

      function buildMetadata(rows) {
        const years = new Set();
        const grades = new Set();
        const settings = new Set();

        rows.forEach((row) => {
          if (row && Number.isFinite(row.year_num)) years.add(row.year_num);
          if (row && row.level) grades.add(row.level);
          if (row && row.setting) settings.add(row.setting);
        });

        return {
          years: Array.from(years).sort((a, b) => a - b).map((year) => formatters.toAcademicYear(year)),
          grades: Array.from(grades).sort((a, b) => a.localeCompare(b)),
          settings: Array.from(settings).sort((a, b) => a.localeCompare(b)),
        };
      }

      function createSelect(id, labelText, options) {
        const wrapper = document.createElement('label');
        wrapper.setAttribute('for', id);
        wrapper.textContent = labelText;

        const select = document.createElement('select');
        select.id = id;
        select.name = id;

        const allOption = document.createElement('option');
        allOption.value = 'All';
        allOption.textContent = 'All';
        select.appendChild(allOption);

        options.forEach((optionValue) => {
          const option = document.createElement('option');
          option.value = optionValue;
          option.textContent = optionValue;
          select.appendChild(option);
        });

        select.value = state[id] || 'All';
        select.addEventListener('change', (event) => {
          state[id] = event.target.value;
          applyFilters();
        });

        wrapper.appendChild(select);
        return wrapper;
      }

      function populateControls(meta) {
        if (!DOM.controls) return;
        DOM.controls.innerHTML = '';

        const controls = [
          { id: 'academicYear', label: 'Academic year', values: meta.years },
          { id: 'gradeLevel', label: 'Grade level', values: meta.grades },
          { id: 'schoolType', label: 'School type', values: meta.settings },
        ];

        controls.forEach((control) => {
          DOM.controls.appendChild(createSelect(control.id, control.label, control.values));
        });
      }

      function toFileSegment(value) {
        if (!value || value === 'All') return 'all';
        return value.toString().toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '') || 'all';
      }

      function buildDownloadFilename() {
        return [
          'tail_concentration',
          toFileSegment(state.academicYear),
          toFileSegment(state.gradeLevel),
          toFileSegment(state.schoolType),
        ].join('_') + '.csv';
      }

      function formatRowsForExport(rows) {
        return rows.map((row) => ([
          formatters.toAcademicYear(row.year_num),
          row.level || '',
          row.setting || '',
          row.top_label || '',
          formatters.integer(row.top_schools ?? 0),
          formatters.integer(row.total_schools ?? 0),
          row.share_pct || formatters.share((row.top_share ?? 0) * 100),
          row.slide_text || '',
        ]));
      }

      function escapeCsv(value) {
        const stringValue = value == null ? '' : String(value);
        return /[",\n]/.test(stringValue) ? `"${stringValue.replace(/"/g, '""')}"` : stringValue;
      }

      function rowsToCsv(rows) {
        const headers = [
          'Academic year',
          'Grade level',
          'School type',
          'Top group',
          'Schools in group',
          'Total schools',
          'Share of suspensions',
          'Statement',
        ];
        const lines = formatRowsForExport(rows).map((row) => row.map(escapeCsv).join(','));
        return [headers.map(escapeCsv).join(','), ...lines].join('\n');
      }

      function updateDownloadState(rows) {
        if (!DOM.download) return;
        const hasRows = rows.length > 0;
        DOM.download.disabled = !hasRows;
        DOM.download.title = hasRows ? '' : 'No data available for the current filters';
      }

      function handleDownloadClick() {
        if (!store.latestExport.length) return;
        const csv = rowsToCsv(store.latestExport);
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = buildDownloadFilename();
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      function filterRows(rows) {
        const yearFilter = formatters.toYearNumber(state.academicYear);
        return rows.filter((row) => {
          if (!row) return false;
          const matchesYear = yearFilter == null || row.year_num === yearFilter;
          const matchesGrade = state.gradeLevel === 'All' || row.level === state.gradeLevel;
          const matchesSetting = state.schoolType === 'All' || row.setting === state.schoolType;
          return matchesYear && matchesGrade && matchesSetting;
        });
      }

      function renderSummaryAndTable(rows) {
        store.latestExport = rows.slice();
        updateDownloadState(rows);

        if (DOM.summary) DOM.summary.textContent = '';
        if (DOM.tableWrapper) DOM.tableWrapper.innerHTML = '';

        if (!rows.length) {
          if (DOM.summary) DOM.summary.textContent = 'No grade-setting statements match the current filters.';
          if (DOM.tableWrapper) {
            const empty = document.createElement('p');
            empty.className = 'empty';
            empty.textContent = 'No prepared statements are available for the selected year, grade level, and school type.';
            DOM.tableWrapper.appendChild(empty);
          }
          return;
        }

        const sorted = rows.slice().sort((a, b) => {
          if (a.year_num !== b.year_num) return a.year_num - b.year_num;
          if (a.level !== b.level) return a.level.localeCompare(b.level);
          if (a.setting !== b.setting) return a.setting.localeCompare(b.setting);
          return (a.top_pct || 0) - (b.top_pct || 0);
        });

        store.latestExport = sorted;

        const grouped = Array.from(sorted.reduce((map, row) => {
          const key = `${row.year_num}|${row.level}|${row.setting}`;
          if (!map.has(key)) {
            map.set(key, {
              year: row.year_num,
              level: row.level,
              setting: row.setting,
              totalSchools: 0,
            });
          }
          const entry = map.get(key);
          const total = Number(row.total_schools);
          if (Number.isFinite(total)) {
            entry.totalSchools = Math.max(entry.totalSchools, total);
          }
          return map;
        }, new Map()).values()).sort((a, b) => {
          if (a.year !== b.year) return a.year - b.year;
          if (a.level !== b.level) return a.level.localeCompare(b.level);
          return a.setting.localeCompare(b.setting);
        });

        const totalSchools = grouped.reduce((sum, entry) => sum + (entry.totalSchools || 0), 0);
        if (DOM.summary) {
          const groupLabel = grouped.length === 1 ? 'group' : 'groups';
          DOM.summary.textContent = `Current filters cover ${formatters.integer(totalSchools)} schools across ${grouped.length} ${groupLabel}.`;
        }

        if (!DOM.tableWrapper) return;
        const table = document.createElement('table');
        table.className = 'summary-table';

        const thead = document.createElement('thead');
        const headRow = document.createElement('tr');
        ['Academic year', 'Grade level', 'School type', 'Total schools'].forEach((heading) => {
          const th = document.createElement('th');
          th.scope = 'col';
          th.textContent = heading;
          headRow.appendChild(th);
        });
        thead.appendChild(headRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        grouped.forEach((entry) => {
          const rowEl = document.createElement('tr');

          const yearCell = document.createElement('td');
          yearCell.textContent = entry.year == null ? 'All' : formatters.toAcademicYear(entry.year);
          rowEl.appendChild(yearCell);

          const levelCell = document.createElement('td');
          levelCell.textContent = entry.level || 'All';
          rowEl.appendChild(levelCell);

          const settingCell = document.createElement('td');
          settingCell.textContent = entry.setting || 'All';
          rowEl.appendChild(settingCell);

          const totalCell = document.createElement('td');
          totalCell.textContent = formatters.integer(entry.totalSchools || 0);
          rowEl.appendChild(totalCell);

          tbody.appendChild(rowEl);
        });

        table.appendChild(tbody);
        DOM.tableWrapper.appendChild(table);
      }

      function aggregateTopShares(rows) {
        const groups = new Map();
        rows.forEach((row) => {
          if (!row || typeof row.top_pct !== 'number') return;
          const key = row.top_pct;
          if (!groups.has(key)) {
            groups.set(key, {
              pct: row.top_pct,
              label: row.top_label || `Top ${Math.round(row.top_pct * 100)}%`,
              shares: [],
            });
          }
          const entry = groups.get(key);
          if (typeof row.top_share === 'number') {
            entry.shares.push(row.top_share * 100);
          } else if (typeof row.share_pct === 'string') {
            const numeric = Number(row.share_pct.replace(/[^\d.\-]/g, ''));
            if (!Number.isNaN(numeric)) entry.shares.push(numeric);
          }
        });

        return Array.from(groups.values()).map((entry) => {
          const total = entry.shares.reduce((sum, value) => sum + value, 0);
          const average = entry.shares.length ? total / entry.shares.length : 0;
          return {
            pct: entry.pct,
            label: entry.label,
            share: Math.max(0, Math.min(100, Number(average.toFixed(1)))),
          };
        }).sort((a, b) => a.pct - b.pct);
      }

      function buildDoughnutSegments(aggregated) {
        const segments = [];
        let previousShare = 0;
        let previousPct = 0;

        aggregated.forEach((entry, index) => {
          const pct = Math.max(0, Math.min(1, entry.pct));
          const cumulativeShare = Math.max(0, Math.min(100, entry.share));
          const incrementalShare = Number(Math.max(0, cumulativeShare - previousShare).toFixed(1));
          const additionalPct = Math.max(0, pct - previousPct);
          const cohortLabel = index === 0
            ? `${entry.label} of schools`
            : `Next ${(additionalPct * 100).toFixed(1)}% of schools`;
          const legendText = index === 0
            ? `${entry.label} of schools: ${incrementalShare.toFixed(1)}% of suspensions`
            : `${cohortLabel}: ${incrementalShare.toFixed(1)}% of suspensions (cumulative ${cumulativeShare.toFixed(1)}%)`;

          segments.push({
            label: cohortLabel,
            legendText,
            tooltipText: legendText,
            value: incrementalShare,
            isRemainder: false,
          });

          previousShare = cumulativeShare;
          previousPct = pct;
        });

        const remainderShare = Number(Math.max(0, 100 - previousShare).toFixed(1));
        const remainderPct = Math.max(0, 1 - previousPct);

        if (remainderShare > 0.05) {
          const label = `Remaining ${(remainderPct * 100).toFixed(1)}% of schools`;
          const legendText = `${label}: ${remainderShare.toFixed(1)}% of suspensions`;
          segments.push({
            label,
            legendText,
            tooltipText: legendText,
            value: remainderShare,
            isRemainder: true,
          });
        }

        return segments;
      }

      function renderCharts(rows) {
        if (typeof Chart === 'undefined') return;
        configureChartDefaults();

        const validRows = rows.filter((row) => row && typeof row.top_pct === 'number'
          && (typeof row.top_share === 'number' || typeof row.share_pct === 'string'));

        const aggregated = aggregateTopShares(validRows);
        const hasData = aggregated.length > 0;

        document.querySelectorAll('[data-chart-empty]').forEach((el) => {
          el.hidden = hasData;
        });

        if (!hasData) {
          if (charts.topShare) {
            charts.topShare.data.labels = [];
            charts.topShare.data.datasets[0].data = [];
            charts.topShare.update('none');
          }
          if (charts.concentration) {
            charts.concentration.data.labels = [];
            charts.concentration.data.datasets[0].data = [];
            charts.concentration.update('none');
          }
          return;
        }

        const barLabels = aggregated.map((entry) => entry.label);
        const barData = aggregated.map((entry) => entry.share);
        const barColors = aggregated.map((_, index) => COLORS[index % COLORS.length]);

        const segments = buildDoughnutSegments(aggregated);
        const doughnutLabels = segments.map((segment) => segment.label);
        const doughnutData = segments.map((segment) => segment.value);
        const doughnutColors = [];
        const doughnutHover = [];
        let colorIndex = 0;

        segments.forEach((segment) => {
          if (segment.isRemainder) {
            doughnutColors.push(REMAINDER_COLOR);
            doughnutHover.push(REMAINDER_HOVER);
          } else {
            const color = COLORS[colorIndex % COLORS.length];
            doughnutColors.push(color);
            doughnutHover.push(color);
            colorIndex += 1;
          }
        });

        const barCanvas = document.getElementById('top-share-chart');
        const doughnutCanvas = document.getElementById('cohort-size-chart');
        if (!barCanvas || !doughnutCanvas) return;

        const barContext = barCanvas.getContext('2d');
        const doughnutContext = doughnutCanvas.getContext('2d');
        if (!barContext || !doughnutContext) return;

        const barConfig = {
          type: 'bar',
          data: {
            labels: barLabels,
            datasets: [{
              label: 'Suspension share',
              data: barData,
              backgroundColor: barColors,
              hoverBackgroundColor: barColors,
              borderRadius: 8,
              borderSkipped: false,
            }],
          },
          options: {
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true,
                ticks: {
                  callback: (value) => `${value}%`,
                },
                grid: { color: 'rgba(39, 116, 174, 0.15)' },
              },
              x: {
                grid: { display: false },
              },
            },
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: (context) => `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`,
                },
              },
            },
          },
        };

        const doughnutConfig = {
          type: 'doughnut',
          data: {
            labels: doughnutLabels,
            datasets: [{
              label: 'Suspension share',
              data: doughnutData,
              backgroundColor: doughnutColors,
              hoverBackgroundColor: doughnutHover,
              borderColor: '#ffffff',
              borderWidth: 2,
            }],
          },
          options: {
            maintainAspectRatio: false,
            cutout: '55%',
            plugins: {
              legend: {
                position: 'right',
                labels: {
                  padding: 18,
                  boxWidth: 18,
                  font: { size: 12 },
                  generateLabels() {
                    return segments.map((segment, index) => ({
                      text: segment.legendText,
                      fillStyle: doughnutColors[index],
                      strokeStyle: '#ffffff',
                      lineWidth: 2,
                      index,
                    }));
                  },
                },
              },
              tooltip: {
                callbacks: {
                  label: (context) => segments[context.dataIndex]?.tooltipText || context.label,
                },
              },
            },
          },
        };

        if (charts.topShare) {
          charts.topShare.data.labels = barLabels;
          charts.topShare.data.datasets[0].data = barData;
          charts.topShare.data.datasets[0].backgroundColor = barColors;
          charts.topShare.data.datasets[0].hoverBackgroundColor = barColors;
          charts.topShare.update();
        } else {
          charts.topShare = new Chart(barContext, barConfig);
        }

        if (charts.concentration) {
          charts.concentration.data.labels = doughnutLabels;
          charts.concentration.data.datasets[0].data = doughnutData;
          charts.concentration.data.datasets[0].backgroundColor = doughnutColors;
          charts.concentration.data.datasets[0].hoverBackgroundColor = doughnutHover;
          charts.concentration.options.plugins.legend.labels.generateLabels = () => segments.map((segment, index) => ({
            text: segment.legendText,
            fillStyle: doughnutColors[index],
            strokeStyle: '#ffffff',
            lineWidth: 2,
            index,
          }));
          charts.concentration.options.plugins.tooltip.callbacks.label = (context) => segments[context.dataIndex]?.tooltipText || context.label;
          charts.concentration.update();
        } else {
          charts.concentration = new Chart(doughnutContext, doughnutConfig);
        }
      }

      function applyFilters() {
        store.filtered = filterRows(store.rows);
        renderSummaryAndTable(store.filtered);
        renderCharts(store.filtered);
      }

      function resetFilters() {
        state.academicYear = 'All';
        state.gradeLevel = 'All';
        state.schoolType = 'All';
        if (DOM.controls) {
          DOM.controls.querySelectorAll('select').forEach((select) => {
            select.value = 'All';
          });
        }
        applyFilters();
      }

      async function init() {
        try {
          const payload = await loadPreparedData();
          store.rows = Array.isArray(payload.gradeSetting) ? payload.gradeSetting.filter((row) => row) : [];

          populateControls(buildMetadata(store.rows));
          if (DOM.reset) {
            DOM.reset.addEventListener('click', resetFilters);
          }
          if (DOM.download) {
            DOM.download.addEventListener('click', handleDownloadClick);
          }

          if (DOM.loading) {
            DOM.loading.hidden = true;
          }
          if (DOM.content) {
            DOM.content.hidden = false;
          }

          applyFilters();
        } catch (error) {
          console.error('Failed to initialize tail concentration dashboard:', error);
          if (DOM.loading) {
            DOM.loading.hidden = false;
            DOM.loading.textContent = 'Unable to load the prepared grade-setting data. Please refresh the page or try again later.';
          }
        }
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>


</body>
</html>
