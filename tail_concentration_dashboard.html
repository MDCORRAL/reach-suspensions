<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Tail Concentration Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
  <script src="https://cdn.plot.ly/plotly-2.31.1.min.js" defer></script>
  <style>
    :root {
      color-scheme: light;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      --bg: #f5f6fa;
      --card-bg: #ffffff;
      --border: #d9dde7;
      --text: #1f2933;
      --muted: #5f6b7c;
      --accent: #4361ee;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
    }

    header {
      background: #10172a;
      color: white;
      padding: 2.5rem 1.5rem 2rem;
      box-shadow: 0 4px 18px rgba(16, 23, 42, 0.25);
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.8rem, 3vw, 2.4rem);
      letter-spacing: -0.01em;
    }

    header p {
      margin: 0.75rem 0 0;
      max-width: 60rem;
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.82);
    }

    main {
      padding: 1.5rem;
      max-width: 1200px;
      margin: 0 auto 4rem;
    }

    .card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 10px 22px rgba(15, 23, 42, 0.08);
    }

    h2 {
      margin-top: 0;
      font-size: 1.35rem;
    }

    h3 {
      margin-top: 0;
      font-size: 1.1rem;
      color: var(--muted);
    }

    #controls {
      display: grid;
      gap: 1rem;
    }

    @media (min-width: 768px) {
      #controls {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    label {
      display: flex;
      flex-direction: column;
      font-size: 0.9rem;
      gap: 0.45rem;
      font-weight: 600;
      color: var(--muted);
    }

    select {
      border-radius: 10px;
      border: 1px solid var(--border);
      padding: 0.55rem 0.75rem;
      font-size: 0.95rem;
      font-family: inherit;
      background: #fff;
      color: var(--text);
      outline: none;
    }

    select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.15);
    }

    .note {
      margin-top: 0.75rem;
      font-size: 0.88rem;
      color: var(--muted);
    }

    .summary {
      font-size: 0.95rem;
      margin-bottom: 1rem;
      color: var(--muted);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }

    thead {
      background: #eef2ff;
      color: #1d2a5c;
    }

    th, td {
      padding: 0.6rem 0.75rem;
      border-bottom: 1px solid var(--border);
      text-align: left;
    }

    tbody tr:last-child td {
      border-bottom: none;
    }

    .empty {
      padding: 1rem;
      background: #f8fafc;
      border-radius: 12px;
      border: 1px dashed var(--border);
      text-align: center;
      color: var(--muted);
    }

    #tail-chart {
      width: 100%;
      min-height: 360px;
    }

    .checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .checkboxes label {
      flex-direction: row;
      align-items: center;
      gap: 0.5rem;
      font-weight: 500;
      color: var(--text);
    }

    button.reset {
      margin-top: 0.75rem;
      border-radius: 999px;
      background: #e6ecff;
      color: #1f3a8a;
      border: none;
      padding: 0.5rem 1rem;
      font-weight: 600;
      cursor: pointer;
    }

    button.reset:hover {
      background: #d9e2ff;
    }

    #loading {
      text-align: center;
      padding: 4rem 1rem;
      font-size: 1.05rem;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <header>
    <h1>Tail Concentration Explorer</h1>
    <p>
      Use the controls below to surface the existing tail concentration outputs produced by the REACH suspension
      analyses. Toggle grade levels, school types, student groups, and enrollment quartiles to see the prepared
      results without running any new computations.
    </p>
  </header>
  <main>
    <div id="loading">Loading pre-computed data…</div>
    <section id="content" hidden>
      <div class="card">
        <h2>Filters</h2>
        <div id="controls"></div>
        <button class="reset" type="button" id="reset-filters">Reset all filters</button>
        <p class="note">
          The selections below simply filter the data that has already been generated by the tail concentration scripts.
          No additional analysis is performed when you make a selection.
        </p>
      </div>

      <section class="card" id="grade-setting-section">
        <h2>Grade level × school type summary</h2>
        <p class="summary" id="grade-summary"></p>
        <div id="grade-table-wrapper"></div>
      </section>

      <section class="card" id="tail-section">
        <h2>Tail concentration by student group</h2>
        <div class="checkboxes" id="threshold-controls"></div>
        <div id="tail-chart"></div>
        <p class="summary" id="tail-summary"></p>
      </section>

      <section class="card" id="quartile-section">
        <h2>Suspension detail for selected quartiles</h2>
        <p class="summary" id="quartile-summary"></p>
        <div id="quartile-table-wrapper"></div>
      </section>
    </section>
  </main>
  <script>
    const state = {
      academicYear: 'All',
      gradeLevel: 'All',
      schoolType: 'All',
      studentGroup: 'All',
      blackQuartile: 'All',
      whiteQuartile: 'All',
      hispanicQuartile: 'All',
      thresholds: new Set([0.05, 0.10, 0.20]),
    };

    const formatters = {
      toAcademicYear(yearNum) {
        if (Number.isNaN(yearNum)) return '';
        const next = String((yearNum + 1)).slice(-2);
        return `${yearNum}-${next}`;
      },
      toYearNumber(acYear) {
        if (!acYear || acYear === 'All') return null;
        const match = acYear.match(/^(\\d{4})/);
        return match ? Number(match[1]) : null;
      },
      rate(value) {
        return value == null ? '—' : `${(value * 100).toFixed(1)} per 100`;
      },
      percent(value) {
        return value == null ? '—' : `${(value * 100).toFixed(1)}%`;
      },
      integer(value) {
        return value == null ? '—' : value.toLocaleString();
      }
    };

    const controls = [
      { id: 'academicYear', label: 'Academic year', options: [] },
      { id: 'gradeLevel', label: 'Grade level', options: [] },
      { id: 'schoolType', label: 'School type', options: [] },
      { id: 'studentGroup', label: 'Race / ethnicity', options: [] },
      { id: 'blackQuartile', label: '% Black enrollment quartile', options: [] },
      { id: 'whiteQuartile', label: '% White enrollment quartile', options: [] },
      { id: 'hispanicQuartile', label: '% Hispanic enrollment quartile', options: [] },
    ];

    const cache = {
      gradeSetting: [],
      tailConcentration: [],
      overall: [],
    };

    function buildOptions(options, includeAll = true) {
      const frag = document.createDocumentFragment();
      if (includeAll) {
        const opt = document.createElement('option');
        opt.value = 'All';
        opt.textContent = 'All';
        frag.appendChild(opt);
      }
      options.forEach((value) => {
        const opt = document.createElement('option');
        opt.value = value;
        opt.textContent = value;
        frag.appendChild(opt);
      });
      return frag;
    }

    function populateControls(meta) {
      const controlsContainer = document.getElementById('controls');
      controlsContainer.innerHTML = '';

      controls.find((c) => c.id === 'academicYear').options = meta.academicYears;
      controls.find((c) => c.id === 'gradeLevel').options = meta.gradeLevels;
      controls.find((c) => c.id === 'schoolType').options = meta.schoolTypes;
      controls.find((c) => c.id === 'studentGroup').options = meta.studentGroups;
      controls.find((c) => c.id === 'blackQuartile').options = meta.blackQuartiles;
      controls.find((c) => c.id === 'whiteQuartile').options = meta.whiteQuartiles;
      controls.find((c) => c.id === 'hispanicQuartile').options = meta.hispanicQuartiles;

      controls.forEach(({ id, label, options }) => {
        const wrapper = document.createElement('label');
        wrapper.setAttribute('for', `${id}-select`);
        wrapper.textContent = label;

        const select = document.createElement('select');
        select.id = `${id}-select`;
        select.name = id;
        select.appendChild(buildOptions(options));
        select.addEventListener('change', (event) => {
          state[id] = event.target.value;
          render();
        });

        wrapper.appendChild(select);
        controlsContainer.appendChild(wrapper);
      });
    }

    function renderGradeTable() {
      const wrapper = document.getElementById('grade-table-wrapper');
      wrapper.innerHTML = '';
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      thead.innerHTML = `
        <tr>
          <th>Academic year</th>
          <th>Level</th>
          <th>School type</th>
          <th>Schools</th>
          <th>Total enrollment</th>
          <th>Total suspensions</th>
          <th>Overall rate</th>
          <th>Mean rate</th>
          <th>Median rate</th>
          <th>75th percentile rate</th>
          <th>90th percentile rate</th>
        </tr>`;
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      let rows = cache.gradeSetting.slice();
      const selectedYearNum = formatters.toYearNumber(state.academicYear);
      if (selectedYearNum) {
        rows = rows.filter((row) => row.year_num === selectedYearNum);
      }
      if (state.gradeLevel !== 'All') {
        rows = rows.filter((row) => row.level === state.gradeLevel);
      }
      if (state.schoolType !== 'All') {
        rows = rows.filter((row) => row.setting === state.schoolType);
      }

      const summary = document.getElementById('grade-summary');
      if (!rows.length) {
        summary.textContent = 'No grade level and school type records match the current filters.';
        wrapper.innerHTML = '<div class="empty">No pre-computed rows available for these filters.</div>';
        return;
      }

      summary.textContent = `Showing ${rows.length} prepared rows summarising ${formatters.integer(rows.reduce((sum, r) => sum + r.n_schools, 0))} schools.`;

      rows
        .sort((a, b) => {
          if (a.year_num !== b.year_num) return a.year_num - b.year_num;
          if (a.level !== b.level) return a.level.localeCompare(b.level);
          return a.setting.localeCompare(b.setting);
        })
        .forEach((row) => {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${formatters.toAcademicYear(row.year_num)}</td>
            <td>${row.level}</td>
            <td>${row.setting}</td>
            <td>${formatters.integer(row.n_schools)}</td>
            <td>${formatters.integer(row.total_enrollment)}</td>
            <td>${formatters.integer(row.total_suspensions)}</td>
            <td>${formatters.rate(row.overall_rate)}</td>
            <td>${formatters.rate(row.mean_rate)}</td>
            <td>${formatters.rate(row.median_rate)}</td>
            <td>${formatters.rate(row.q75_rate)}</td>
            <td>${formatters.rate(row.q90_rate)}</td>`;
          tbody.appendChild(tr);
        });

      table.appendChild(tbody);
      wrapper.appendChild(table);
    }

    function buildThresholdControls() {
      const thresholds = [0.05, 0.1, 0.2];
      const thresholdLabels = {
        0.05: 'Top 5% of schools',
        0.1: 'Top 10% of schools',
        0.2: 'Top 20% of schools',
      };
      const container = document.getElementById('threshold-controls');
      container.innerHTML = '';
      thresholds.forEach((value) => {
        const label = document.createElement('label');
        const input = document.createElement('input');
        input.type = 'checkbox';
        input.value = value;
        input.checked = state.thresholds.has(value);
        input.addEventListener('change', (event) => {
          const v = Number(event.target.value);
          if (event.target.checked) {
            state.thresholds.add(v);
          } else {
            state.thresholds.delete(v);
          }
          renderTailChart();
        });
        label.appendChild(input);
        label.appendChild(document.createTextNode(thresholdLabels[value]));
        container.appendChild(label);
      });
    }

    function renderTailChart() {
      const year = state.academicYear === 'All' ? null : state.academicYear;
      let rows = cache.tailConcentration.slice();
      if (year) {
        rows = rows.filter((row) => row.academic_year === year);
      }
      if (state.studentGroup !== 'All') {
        rows = rows.filter((row) => row.student_group === state.studentGroup);
      }

      const summary = document.getElementById('tail-summary');
      const thresholds = Array.from(state.thresholds).sort();
      if (!thresholds.length) {
        Plotly.purge('tail-chart');
        summary.textContent = 'Select at least one threshold to display the existing shares.';
        return;
      }

      if (!rows.length) {
        Plotly.purge('tail-chart');
        summary.textContent = 'No tail concentration rows match the current filters.';
        return;
      }

      const groups = Array.from(new Set(rows.map((row) => row.student_group))).sort();
      const traces = thresholds.map((thr, idx) => ({
        type: 'bar',
        name: `Top ${Math.round(thr * 100)}%`,
        x: groups,
        y: groups.map((group) => {
          const match = rows.find((row) => row.student_group === group && row.threshold === thr);
          return match && match.share != null ? Number((match.share * 100).toFixed(1)) : null;
        }),
        marker: { color: ['#2563eb', '#7c3aed', '#0f766e'][idx % 3] },
      }));

      Plotly.newPlot('tail-chart', traces, {
        barmode: 'group',
        margin: { t: 30, r: 20, b: 80, l: 60 },
        yaxis: { title: 'Share of suspensions (%)', rangemode: 'tozero' },
        xaxis: { title: 'Student group' },
        legend: { orientation: 'h', x: 0, y: 1.1 },
        displayModeBar: false,
      });

      const yearLabel = year ? year : 'all available years';
      summary.textContent = `Shares are pre-computed for ${groups.length} student groups in ${yearLabel}.`;
    }

    function renderQuartileTable() {
      const wrapper = document.getElementById('quartile-table-wrapper');
      wrapper.innerHTML = '';
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      thead.innerHTML = `
        <tr>
          <th>Academic year</th>
          <th>Grade level</th>
          <th>Student group</th>
          <th>% Black quartile</th>
          <th>% White quartile</th>
          <th>% Hispanic quartile</th>
          <th>Enrollment</th>
          <th>Total suspensions</th>
          <th>Suspension rate</th>
          <th>Students suspended</th>
          <th>Student suspension rate</th>
        </tr>`;
      table.appendChild(thead);
      const tbody = document.createElement('tbody');

      let rows = cache.overall.slice();
      if (state.academicYear !== 'All') {
        rows = rows.filter((row) => row.academic_year === state.academicYear);
      }
      if (state.gradeLevel !== 'All') {
        rows = rows.filter((row) => row.school_level_final === state.gradeLevel);
      }
      if (state.studentGroup !== 'All') {
        rows = rows.filter((row) => row.reporting_category_description === state.studentGroup);
      }
      if (state.blackQuartile !== 'All') {
        rows = rows.filter((row) => row.black_prop_q_label === state.blackQuartile);
      }
      if (state.whiteQuartile !== 'All') {
        rows = rows.filter((row) => row.white_prop_q_label === state.whiteQuartile);
      }
      if (state.hispanicQuartile !== 'All') {
        rows = rows.filter((row) => row.hispanic_prop_q_label === state.hispanicQuartile);
      }

      const summary = document.getElementById('quartile-summary');
      if (!rows.length) {
        summary.textContent = 'No quartile detail is available for the selected filters.';
        wrapper.innerHTML = '<div class="empty">No rows match this combination of quartiles, grade level, and group.</div>';
        return;
      }

      summary.textContent = `Displaying ${rows.length} prepared rows. Values are displayed exactly as exported by the existing pipeline.`;

      rows
        .sort((a, b) => {
          if (a.academic_year !== b.academic_year) return a.academic_year.localeCompare(b.academic_year);
          if (a.school_level_final !== b.school_level_final) return a.school_level_final.localeCompare(b.school_level_final);
          return a.reporting_category_description.localeCompare(b.reporting_category_description);
        })
        .slice(0, 400)
        .forEach((row) => {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${row.academic_year}</td>
            <td>${row.school_level_final}</td>
            <td>${row.reporting_category_description}</td>
            <td>${row.black_prop_q_label}</td>
            <td>${row.white_prop_q_label}</td>
            <td>${row.hispanic_prop_q_label}</td>
            <td>${formatters.integer(row.enrollment)}</td>
            <td>${formatters.integer(row.total_suspensions)}</td>
            <td>${formatters.rate(row.suspension_rate)}</td>
            <td>${formatters.integer(row.students_suspended)}</td>
            <td>${formatters.rate(row.student_rate)}</td>`;
          tbody.appendChild(tr);
        });

      table.appendChild(tbody);
      wrapper.appendChild(table);

      if (rows.length > 400) {
        const note = document.createElement('p');
        note.className = 'note';
        note.textContent = 'Only the first 400 rows are shown to keep the table manageable. Exporting the JSON will reveal the full set.';
        wrapper.appendChild(note);
      }
    }

    function render() {
      renderGradeTable();
      renderTailChart();
      renderQuartileTable();
    }

    function buildMetaFromData() {
      const academicYears = Array.from(new Set([
        ...cache.tailConcentration.map((row) => row.academic_year),
        ...cache.overall.map((row) => row.academic_year),
      ])).sort();

      const gradeLevels = Array.from(new Set([
        ...cache.gradeSetting.map((row) => row.level),
        ...cache.overall.map((row) => row.school_level_final),
      ])).filter(Boolean).sort();

      const schoolTypes = Array.from(new Set(cache.gradeSetting.map((row) => row.setting))).sort();
      const studentGroups = Array.from(new Set(cache.tailConcentration.map((row) => row.student_group))).sort();
      const blackQuartiles = Array.from(new Set(cache.overall.map((row) => row.black_prop_q_label))).filter(Boolean).sort();
      const whiteQuartiles = Array.from(new Set(cache.overall.map((row) => row.white_prop_q_label))).filter(Boolean).sort();
      const hispanicQuartiles = Array.from(new Set(cache.overall.map((row) => row.hispanic_prop_q_label))).filter(Boolean).sort();

      return {
        academicYears,
        gradeLevels,
        schoolTypes,
        studentGroups,
        blackQuartiles,
        whiteQuartiles,
        hispanicQuartiles,
      };
    }

    function resetFilters() {
      Object.assign(state, {
        academicYear: 'All',
        gradeLevel: 'All',
        schoolType: 'All',
        studentGroup: 'All',
        blackQuartile: 'All',
        whiteQuartile: 'All',
        hispanicQuartile: 'All',
      });
      state.thresholds = new Set([0.05, 0.1, 0.2]);
      document.querySelectorAll('#controls select').forEach((select) => {
        select.value = 'All';
      });
      buildThresholdControls();
      render();
    }

    function init() {
      Promise.all([
        fetch('dashboard/pareto_grade_setting_payload.json').then((response) => response.json()),
        fetch(`dashboard/data/dashboard_data.json?v=${Date.now()}`).then((response) => response.json()),
      ])
        .then(([gradePayload, dashboardData]) => {
          cache.gradeSetting = gradePayload.gradeSetting || [];
          cache.tailConcentration = dashboardData.tail_concentrations || [];
          cache.overall = dashboardData.overall || [];

          populateControls(buildMetaFromData());
          buildThresholdControls();
          document.getElementById('reset-filters').addEventListener('click', resetFilters);

          document.getElementById('loading').hidden = true;
          document.getElementById('content').hidden = false;
          render();
        })
        .catch((error) => {
          console.error('Failed to load prepared data', error);
          document.getElementById('loading').textContent = 'Unable to load the prepared tail concentration data.';
        });
    }

    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
