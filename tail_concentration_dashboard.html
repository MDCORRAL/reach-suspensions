<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Tail Concentration Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  <style>
    :root {
      color-scheme: light;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      --bg: #daebfe;
      --card-bg: #ffffff;
      --border: #8bb8e8;
      --text: #003b5c;
      --muted: rgba(0, 59, 92, 0.8);
      --accent: #2774ae;
      --accent-strong: #005587;
      --accent-soft: #8bb8e8;
      --highlight: #ffb81c;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
    }

    header {
      background: var(--accent-strong);
      color: #ffffff;
      padding: 2.5rem 1.5rem 2rem;
      box-shadow: 0 4px 18px rgba(0, 59, 92, 0.35);
    }

    .header-top {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .methodology-button {
      margin-left: auto;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      border: none;
      background: var(--highlight);
      color: var(--accent-strong);
      font-weight: 600;
      padding: 0.55rem 1.1rem;
      border-radius: 999px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      text-decoration: none;
    }

    .methodology-button:hover {
      background: #ffc85b;
      box-shadow: 0 8px 18px rgba(0, 59, 92, 0.25);
      transform: translateY(-1px);
    }

    .methodology-button:focus-visible {
      outline: 2px solid #ffd277;
      outline-offset: 3px;
      box-shadow: 0 0 0 4px rgba(255, 184, 28, 0.35);
    }

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.95rem;
      font-weight: 600;
      color: rgba(218, 235, 254, 0.95);
      text-decoration: none;
      padding: 0.45rem 0.85rem;
      border-radius: 999px;
      background: rgba(0, 59, 92, 0.35);
      transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
    }

    .back-link:hover {
      background: rgba(0, 59, 92, 0.55);
      color: #ffffff;
      transform: translateX(-2px);
    }

    .back-link:focus-visible {
      outline: 2px solid var(--highlight);
      outline-offset: 3px;
      box-shadow: 0 0 0 4px rgba(255, 184, 28, 0.3);
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.8rem, 3vw, 2.4rem);
      letter-spacing: -0.01em;
    }

    header p {
      margin: 0.75rem 0 0;
      max-width: 60rem;
      font-size: 1rem;
      color: rgba(218, 235, 254, 0.85);
    }

    main {
      padding: 1.5rem;
      max-width: 1200px;
      margin: 0 auto 4rem;
    }

    .card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 10px 22px rgba(0, 59, 92, 0.1);
    }

    h2 {
      margin-top: 0;
      font-size: 1.35rem;
    }

    h3 {
      margin-top: 0;
      font-size: 1.1rem;
      color: var(--muted);
    }

    #controls {
      display: grid;
      gap: 1rem;
    }

    @media (min-width: 768px) {
      #controls {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    @media (max-width: 600px) {
      .header-top {
        flex-wrap: wrap;
        margin-bottom: 1.25rem;
      }

      .back-link {
        font-size: 0.9rem;
        padding: 0.4rem 0.75rem;
      }

      .methodology-button {
        margin-left: 0;
        width: 100%;
        justify-content: center;
      }
    }

    label {
      display: flex;
      flex-direction: column;
      font-size: 0.9rem;
      gap: 0.45rem;
      font-weight: 600;
      color: var(--muted);
    }

    select {
      border-radius: 10px;
      border: 1px solid var(--border);
      padding: 0.55rem 0.75rem;
      font-size: 0.95rem;
      font-family: inherit;
      background: var(--card-bg);
      color: var(--text);
      outline: none;
    }

    select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(39, 116, 174, 0.3);
    }

    .note {
      margin-top: 0.75rem;
      font-size: 0.88rem;
      color: var(--muted);
    }

    .summary {
      font-size: 0.95rem;
      margin-bottom: 1rem;
      color: var(--muted);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }

    thead {
      background: var(--accent-soft);
      color: var(--text);
    }

    th, td {
      padding: 0.6rem 0.75rem;
      border-bottom: 1px solid var(--border);
      text-align: left;
    }

    td.statement {
      max-width: 28rem;
      white-space: normal;
      line-height: 1.35;
    }

    tbody tr:last-child td {
      border-bottom: none;
    }

    .empty {
      padding: 1rem;
      background: rgba(218, 235, 254, 0.75);
      border-radius: 12px;
      border: 1px dashed var(--border);
      text-align: center;
      color: var(--muted);
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-top: 0.75rem;
    }

    .button-row button {
      border-radius: 999px;
      border: none;
      padding: 0.5rem 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.2s ease, color 0.2s ease;
    }

    button.reset {
      background: var(--accent-soft);
      color: var(--text);
    }

    button.reset:hover {
      background: var(--accent);
      color: #ffffff;
    }


    #download-csv {
      background: var(--accent);
      color: #ffffff;
    }

    #download-csv:hover:not(:disabled) {
      background: var(--accent-strong);
    }

    #download-csv:disabled {
      background: var(--border);
      color: var(--muted);
      cursor: not-allowed;
    }

    #loading {
      text-align: center;
      padding: 4rem 1rem;
      font-size: 1.05rem;
      color: var(--muted);
    }

    .info-card h3 {
      font-size: 1rem;
      color: var(--accent-strong);
      text-transform: uppercase;
      letter-spacing: 0.04em;
      margin-bottom: 0.25rem;
    }

    .info-card section + section {
      margin-top: 1.25rem;
      padding-top: 1rem;
      border-top: 1px solid rgba(0, 59, 92, 0.15);
    }

    .info-card ul {
      margin: 0.35rem 0 0.75rem;
      padding-left: 1.25rem;
      font-size: 0.95rem;
      line-height: 1.55;
    }

    .info-card p {
      font-size: 0.95rem;
      line-height: 1.55;
      margin: 0.35rem 0 0.75rem;
    }

    .info-links {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-top: 1.5rem;
    }

    .info-links a {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      background: var(--accent);
      color: #ffffff;
      padding: 0.5rem 1rem;
      border-radius: 999px;
      text-decoration: none;
      font-weight: 600;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .info-links a:hover {
      background: var(--accent-strong);
      transform: translateY(-1px);
    }

    .info-links a:focus-visible {
      outline: 2px solid var(--highlight);
      outline-offset: 3px;
      box-shadow: 0 0 0 4px rgba(255, 184, 28, 0.4);
    }
  </style>
</head>
<body>
  <header>
    <div class="header-top">
      <a class="back-link" href="index.html">← Back to dashboard home</a>
      <a class="methodology-button" href="#methodology-and-filters">
        Methodology &amp; filters
      </a>
    </div>
    <h1>Tail Concentration Explorer</h1>
    <p>
      Use the controls below to surface the existing grade-setting outputs produced by the REACH suspension
      analyses. Toggle grade levels and school types to see the prepared results without running any new
      computations.
    </p>
  </header>
  <main>
    <div id="loading">Loading pre-computed data…</div>
    <section id="content" hidden>
      <div class="card">
        <h2>Filters</h2>
        <div id="controls"></div>
        <div class="button-row">
          <button type="button" id="download-csv" disabled>Download CSV</button>
          <button class="reset" type="button" id="reset-filters">Reset all filters</button>
        </div>
        <p class="note">
          The selections above simply filter the data that has already been generated by the grade-setting script.
          No additional analysis is performed when you make a selection.
        </p>
      </div>

      <section class="dashboard" aria-label="Tail concentration visuals">
        <article class="chart-container">
          <h3>Suspension share captured by top cohorts</h3>
          <p class="chart-description">
            Compare how much of the suspension count is concentrated among the top cohorts selected in the prepared
            grade-setting analysis.
          </p>
          <div class="chart-wrapper">
            <canvas id="top-share-chart" aria-label="Chart showing suspension share captured by top groups" role="img"></canvas>
          </div>
          <p class="chart-empty" data-chart-empty hidden>No chart data available for these filters.</p>
        </article>
        <article class="chart-container">
          <h3>Suspension concentration breakdown</h3>
          <p class="chart-description">
            Revisit how each cohort contributes to the total share of suspensions by reframing the same prepared values in
            a complementary donut view.
          </p>
          <div class="chart-wrapper">
            <canvas id="cohort-size-chart" aria-label="Chart showing suspension share contributed by each cohort" role="img"></canvas>
          </div>
          <p class="chart-empty" data-chart-empty hidden>No chart data available for these filters.</p>
        </article>

        <section class="card table-card" id="grade-setting-section">
          <h2>Grade level × school type summary</h2>
          <p class="summary" id="grade-summary"></p>
          <div id="grade-table-wrapper"></div>
        </section>
      </section>

      <section class="card info-card" id="methodology-and-filters" aria-labelledby="methodology-title">
        <h2 id="methodology-title">Methodology &amp; filters</h2>
        <section aria-labelledby="data-sources-heading">
          <h3 id="data-sources-heading">Data sources</h3>
          <p>
            Tail concentration metrics reuse the staged parquet files produced by the REACH pipeline. Suspension totals come
            from <code>susp_v*.parquet</code> files that include school-level counts, while <code>susp_v6_features.parquet</code>
            supplies school type and traditional vs. non-traditional tags used for grouping. Only records with valid
            enrollment and suspension counts are included.
          </p>
        </section>
        <section aria-labelledby="top-share-heading">
          <h3 id="top-share-heading">Top-share definitions</h3>
          <ul>
            <li>Schools are sorted within each academic year × level × setting group by total suspensions.</li>
            <li>The analysis reports what share of suspensions is captured by the top 5%, 10%, and 20% of schools in each group.</li>
            <li>Slide-ready statements shown in the table mirror the prepared CSV export from the grade-setting workflow.</li>
          </ul>
        </section>
        <section aria-labelledby="filter-behavior-heading">
          <h3 id="filter-behavior-heading">Filter behavior</h3>
          <ul>
            <li>The dropdowns surface pre-computed results; switching filters does not rerun any analysis.</li>
            <li>Academic year options are derived from the staged dataset and appear in ascending order.</li>
            <li>Resetting filters returns all dropdowns to “All” and repopulates the full prepared statement list.</li>
          </ul>
        </section>
        <div class="info-links" aria-label="Full documentation links">
          <a href="Analysis/data_processing_overview.md" target="_blank" rel="noopener">Read the data processing overview</a>
          <a href="Analysis/README_tail_concentration_by_level.md" target="_blank" rel="noopener">Read the tail concentration methodology</a>
        </div>
      </section>
    </section>
  </main>
  <script>
    const state = {
      academicYear: 'All',
      gradeLevel: 'All',
      schoolType: 'All',
    };

    const charts = {
      topShare: null,
      concentrationBreakdown: null,
    };

    const formatters = {
      toAcademicYear(yearNum) {
        if (Number.isNaN(yearNum)) return '';
        const next = String((yearNum + 1)).slice(-2);
        return `${yearNum}-${next}`;
      },
      toYearNumber(acYear) {
        if (!acYear || acYear === 'All') return null;
        const match = acYear.match(/^(\d{4})/);
        return match ? Number(match[1]) : null;
      },
      rate(value) {
        return value == null ? '—' : `${(value * 100).toFixed(1)} per 100`;
      },
      percent(value) {
        return value == null ? '—' : `${(value * 100).toFixed(1)}%`;
      },
      integer(value) {
        return value == null ? '—' : value.toLocaleString();
      }
    };

    const controls = [
      { id: 'academicYear', label: 'Academic year', options: [] },
      { id: 'gradeLevel', label: 'Grade level', options: [] },
      { id: 'schoolType', label: 'School type', options: [] },
    ];

    const cache = {
      gradeSetting: [],
    };

    function buildOptions(options, includeAll = true) {
      const frag = document.createDocumentFragment();
      if (includeAll) {
        const opt = document.createElement('option');
        opt.value = 'All';
        opt.textContent = 'All';
        frag.appendChild(opt);
      }
      options.forEach((value) => {
        const opt = document.createElement('option');
        opt.value = value;
        opt.textContent = value;
        frag.appendChild(opt);
      });
      return frag;
    }

    function populateControls(meta) {
      const controlsContainer = document.getElementById('controls');
      if (!controlsContainer) return;

      controlsContainer.innerHTML = '';

      controls.find((c) => c.id === 'academicYear').options = meta.academicYears;
      controls.find((c) => c.id === 'gradeLevel').options = meta.gradeLevels;
      controls.find((c) => c.id === 'schoolType').options = meta.schoolTypes;

      controls.forEach(({ id, label, options }) => {
        const wrapper = document.createElement('label');
        wrapper.setAttribute('for', `${id}-select`);
        wrapper.textContent = label;

        const select = document.createElement('select');
        select.id = `${id}-select`;
        select.name = id;
        select.appendChild(buildOptions(options));
        select.value = state[id];
        select.addEventListener('change', (event) => {
          state[id] = event.target.value;
          render();
        });

        wrapper.appendChild(select);
        controlsContainer.appendChild(wrapper);
      });
    }

    let latestRenderedRows = [];

    function updateDownloadButton(hasRows) {
      const button = document.getElementById('download-csv');
      if (!button) return;
      button.disabled = !hasRows;
      button.title = hasRows ? '' : 'No data available for the current filters';
    }

    function formatRowsForExport(rows) {
      return rows.map((row) => ([
        formatters.toAcademicYear(row.year_num),
        row.level || '',
        row.setting || '',
        row.top_label || '',
        formatters.integer(row.top_schools || 0),
        formatters.integer(row.total_schools || 0),
        row.share_pct || '',
        row.slide_text || '',
      ]));
    }

    function escapeCsvValue(value) {
      const stringValue = value == null ? '' : String(value);
      if (/[",\n]/.test(stringValue)) {
        return `"${stringValue.replace(/"/g, '""')}"`;
      }
      return stringValue;
    }

    function rowsToCsv(rows) {
      const headers = [
        'Academic year',
        'Level',
        'School type',
        'Top group',
        'Schools in group',
        'Total schools',
        'Share of suspensions',
        'Statement',
      ];
      const lines = formatRowsForExport(rows).map((row) => row.map(escapeCsvValue).join(','));
      return [headers.map(escapeCsvValue).join(','), ...lines].join('\n');
    }

    function toFileSegment(value) {
      if (!value || value === 'All') return 'all';
      const slug = value
        .toString()
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-');
      const trimmed = slug.replace(/^-+|-+$/g, '');
      return trimmed || 'all';
    }

    function buildDownloadFilename() {
      const parts = [
        'tail_concentration',
        toFileSegment(state.academicYear),
        toFileSegment(state.gradeLevel),
        toFileSegment(state.schoolType),
      ];
      return `${parts.join('_')}.csv`;
    }

    function triggerCsvDownload() {
      if (!latestRenderedRows.length) return;
      const csvText = rowsToCsv(latestRenderedRows);
      const blob = new Blob([csvText], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = buildDownloadFilename();
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    const downloadButtonEl = document.getElementById('download-csv');
    if (downloadButtonEl) {
      downloadButtonEl.addEventListener('click', triggerCsvDownload);
    }

    function getFilteredRows() {
      if (!Array.isArray(cache.gradeSetting)) {
        return [];
      }

      const yearFilter = formatters.toYearNumber(state.academicYear);
      const gradeFilter = state.gradeLevel;
      const schoolFilter = state.schoolType;

      return cache.gradeSetting.filter((row) => {
        if (!row) return false;
        const matchesYear = yearFilter == null || row.year_num === yearFilter;
        const matchesGrade = gradeFilter === 'All' || row.level === gradeFilter;
        const matchesSchool = schoolFilter === 'All' || row.setting === schoolFilter;
        return matchesYear && matchesGrade && matchesSchool;
      });
    }

    function configureChartDefaults() {
      if (typeof Chart === 'undefined' || !Chart.defaults) return;
      const styles = getComputedStyle(document.documentElement);
      const fontFamily = styles.getPropertyValue('font-family') ||
        "'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
      const textColor = styles.getPropertyValue('--text') || '#003b5c';

      Chart.defaults.font.family = fontFamily.trim();
      Chart.defaults.color = textColor.trim();
      Chart.defaults.plugins.legend.labels.usePointStyle = true;
      Chart.defaults.plugins.tooltip.backgroundColor = 'rgba(0, 59, 92, 0.9)';
    }

    function renderGradeTable(rows = []) {
      latestRenderedRows = [];

      const summaryEl = document.getElementById('grade-summary');
      const tableWrapper = document.getElementById('grade-table-wrapper');

      if (summaryEl) summaryEl.textContent = '';
      if (tableWrapper) tableWrapper.innerHTML = '';

      if (!Array.isArray(rows) || rows.length === 0) {
        updateDownloadButton(false);
        if (summaryEl) summaryEl.textContent = 'No grade-setting statements match the current filters.';
        if (tableWrapper) {
          const empty = document.createElement('p');
          empty.className = 'empty';
          empty.textContent = 'No prepared statements are available for the selected year, grade level, and school type.';
          tableWrapper.appendChild(empty);
        }
        return;
      }

      const sortedRows = [...rows]
        .sort((a, b) => {
          if (a.year_num !== b.year_num) return a.year_num - b.year_num;
          if (a.level !== b.level) return a.level.localeCompare(b.level);
          if (a.setting !== b.setting) return a.setting.localeCompare(b.setting);
          return (a.top_pct || 0) - (b.top_pct || 0);
        });

      latestRenderedRows = sortedRows;
      updateDownloadButton(true);

      const grouped = Array.from(sortedRows.reduce((map, row) => {
        if (!row) return map;
        const yearNum = row.year_num ?? null;
        const level = row.level || 'All';
        const setting = row.setting || 'All';
        const key = `${yearNum ?? 'All'}|${level}|${setting}`;
        if (!map.has(key)) {
          map.set(key, {
            yearNum,
            level,
            setting,
            totalSchools: 0,
          });
        }
        const entry = map.get(key);
        const total = Number(row.total_schools);
        if (!Number.isNaN(total)) {
          entry.totalSchools = Math.max(entry.totalSchools, total);
        }
        return map;
      }, new Map()).values())
        .sort((a, b) => {
          if ((a.yearNum ?? 0) !== (b.yearNum ?? 0)) {
            return (a.yearNum ?? 0) - (b.yearNum ?? 0);
          }
          if (a.level !== b.level) return a.level.localeCompare(b.level);
          return a.setting.localeCompare(b.setting);
        });

      const totalSchoolsCount = grouped.reduce((sum, entry) => sum + (entry.totalSchools || 0), 0);

      if (summaryEl) {
        const groupLabel = grouped.length === 1 ? 'group' : 'groups';
        summaryEl.textContent = `Current filters cover ${formatters.integer(totalSchoolsCount)} schools across ${grouped.length} ${groupLabel}.`;
      }

      if (!tableWrapper) return;

      const table = document.createElement('table');
      table.className = 'summary-table';

      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      ['Academic year', 'Grade level', 'School type', 'Total schools'].forEach((heading) => {
        const th = document.createElement('th');
        th.scope = 'col';
        th.textContent = heading;
        headRow.appendChild(th);
      });
      thead.appendChild(headRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      grouped.forEach((entry) => {
        const rowEl = document.createElement('tr');

        const yearCell = document.createElement('td');
        yearCell.textContent = entry.yearNum == null ? 'All' : formatters.toAcademicYear(entry.yearNum);
        rowEl.appendChild(yearCell);

        const levelCell = document.createElement('td');
        levelCell.textContent = entry.level || 'All';
        rowEl.appendChild(levelCell);

        const settingCell = document.createElement('td');
        settingCell.textContent = entry.setting || 'All';
        rowEl.appendChild(settingCell);

        const totalCell = document.createElement('td');
        totalCell.textContent = formatters.integer(entry.totalSchools || 0);
        rowEl.appendChild(totalCell);

        tbody.appendChild(rowEl);
      });

      table.appendChild(tbody);
      tableWrapper.appendChild(table);
    }

    function render() {
      const rows = getFilteredRows();
      renderGradeTable(rows);
      renderCharts(rows);
    }

    function renderCharts(rows) {
      if (typeof Chart === 'undefined') return;
      configureChartDefaults();
      const emptyStates = document.querySelectorAll('[data-chart-empty]');
      const chartRows = Array.isArray(rows)
        ? rows.filter((row) => (
          row
          && typeof row.top_label === 'string'
          && typeof row.top_share === 'number'
          && typeof row.top_pct === 'number'
        ))
        : [];
      const hasData = chartRows.length > 0;
      emptyStates.forEach((el) => {
        el.hidden = hasData;
      });

      if (!hasData) {
        if (charts.topShare) {
          charts.topShare.data.labels = [];
          charts.topShare.data.datasets[0].data = [];
          charts.topShare.update('none');
        }
        if (charts.concentrationBreakdown) {
          charts.concentrationBreakdown.data.labels = [];
          charts.concentrationBreakdown.data.datasets[0].data = [];
          charts.concentrationBreakdown.update('none');
        }
        return;
      }

      const aggregated = Array.from(
        chartRows.reduce((map, row) => {
          if (!row || !row.top_label) return map;
          const key = row.top_label;
          if (!map.has(key)) {
            map.set(key, {
              label: key,
              pct: row.top_pct ?? 0,
              shares: [],
            });
          }
          const group = map.get(key);
          if (typeof row.top_pct === 'number') {
            group.pct = row.top_pct;
          }
          if (typeof row.top_share === 'number') {
            group.shares.push(row.top_share);
          }
          return map;
        }, new Map()).values()
      )
        .map((group) => {
          const avg = (arr) => (arr.length ? arr.reduce((sum, value) => sum + value, 0) / arr.length : 0);
          return {
            label: group.label,
            pct: group.pct ?? 0,
            share: avg(group.shares) * 100,
          };
        })
        .sort((a, b) => (a.pct || 0) - (b.pct || 0));

      const labels = aggregated.map((item) => item.label);
      const suspensionShare = aggregated.map((item) => Number(item.share.toFixed(1)));

      const uclaSuspensionColors = ['#2774AE', '#FFB81C', '#8BB8E8', '#005587', '#FFC72C'];
      const suspensionColors = labels.map((_, index) => uclaSuspensionColors[index % uclaSuspensionColors.length]);
      const suspensionHoverColors = suspensionColors.slice();

      const toShareString = (value) => `${value.toFixed(1)}%`;

      const doughnutSegments = [];
      let previousShare = 0;
      let previousPct = 0;
      aggregated.forEach((item, index) => {
        const pctValue = typeof item.pct === 'number' ? Math.min(1, Math.max(0, item.pct)) : 0;
        const cumulativeShare = Number(Math.max(0, Math.min(100, item.share)).toFixed(1));
        const incrementalShare = Number(Math.max(0, cumulativeShare - previousShare).toFixed(1));
        const additionalPct = Math.max(0, pctValue - previousPct);
        const cohortLabel = index === 0
          ? `${item.label} of schools`
          : `Next ${formatters.percent(additionalPct)} of schools (${item.label})`;
        const legendText = index === 0
          ? `${item.label} of schools: ${toShareString(cumulativeShare)} of suspensions`
          : `${cohortLabel}: ${toShareString(incrementalShare)} of suspensions (cumulative ${toShareString(cumulativeShare)})`;

        doughnutSegments.push({
          label: cohortLabel,
          legendText,
          tooltipText: index === 0
            ? `${item.label} of schools: ${toShareString(incrementalShare)} of suspensions`
            : `${cohortLabel}: ${toShareString(incrementalShare)} of suspensions (cumulative ${toShareString(cumulativeShare)})`,
          value: incrementalShare,
          isRemainder: false,
        });

        previousShare = cumulativeShare;
        previousPct = pctValue;
      });

      const remainderShare = Number(Math.max(0, 100 - previousShare).toFixed(1));
      const remainderPct = Math.max(0, 1 - previousPct);
      const hasRemainderSlice = remainderShare > 0;
      if (hasRemainderSlice) {
        doughnutSegments.push({
          label: `Remaining ${formatters.percent(remainderPct)} of schools`,
          legendText: `Remaining ${formatters.percent(remainderPct)} of schools: ${toShareString(remainderShare)} of suspensions`,
          tooltipText: `Remaining ${formatters.percent(remainderPct)} of schools: ${toShareString(remainderShare)} of suspensions`,
          value: remainderShare,
          isRemainder: true,
        });
      }

      const remainderColor = 'rgba(39, 116, 174, 0.18)';
      const remainderHoverColor = 'rgba(39, 116, 174, 0.32)';

      const doughnutLabels = doughnutSegments.map((segment) => segment.label);
      const doughnutData = doughnutSegments.map((segment) => segment.value);
      const doughnutColors = [];
      const doughnutHoverColors = [];
      let colorIndex = 0;
      doughnutSegments.forEach((segment) => {
        if (segment.isRemainder) {
          doughnutColors.push(remainderColor);
          doughnutHoverColors.push(remainderHoverColor);
        } else {
          const color = uclaSuspensionColors[colorIndex % uclaSuspensionColors.length];
          doughnutColors.push(color);
          doughnutHoverColors.push(color);
          colorIndex += 1;
        }
      });

      const topShareCanvas = document.getElementById('top-share-chart');
      if (!topShareCanvas) return;
      const topShareContext = topShareCanvas.getContext('2d');
      if (!topShareContext) return;
      const topShareConfig = {
        type: 'bar',
        data: {
          labels,
          datasets: [
            {
              label: 'Suspension share',
              data: suspensionShare,
              backgroundColor: suspensionColors,
              hoverBackgroundColor: suspensionHoverColors,
              borderRadius: 8,
              borderSkipped: false,
            },
          ],
        },
        options: {
          maintainAspectRatio: false,
          scales: {
            y: {
              ticks: {
                callback: (value) => `${value}%`,
              },
              grid: {
                color: 'rgba(39, 116, 174, 0.15)',
              },
            },
            x: {
              grid: {
                display: false,
              },
            },
          },
          plugins: {
            tooltip: {
              callbacks: {
                label: (context) => `${context.dataset.label}: ${context.parsed.y}%`,
              },
            },
            legend: {
              display: false,
            },
          },
        },
      };

      if (charts.topShare) {
        charts.topShare.data.labels = labels;
        charts.topShare.data.datasets[0].data = suspensionShare;
        charts.topShare.data.datasets[0].backgroundColor = suspensionColors;
        charts.topShare.data.datasets[0].hoverBackgroundColor = suspensionHoverColors;
        charts.topShare.update();
      } else {
        charts.topShare = new Chart(topShareContext, topShareConfig);
      }

      const cohortCanvas = document.getElementById('cohort-size-chart');
      if (!cohortCanvas) return;
      const cohortContext = cohortCanvas.getContext('2d');
      if (!cohortContext) return;
      const cohortConfig = {
        type: 'doughnut',
        data: {
          labels: doughnutLabels,
          datasets: [
            {
              label: 'Suspension share',
              data: doughnutData,
              backgroundColor: doughnutColors,
              hoverBackgroundColor: doughnutHoverColors,
              borderColor: '#ffffff',
              borderWidth: 2,
            },
          ],
        },
        options: {
          maintainAspectRatio: false,
          cutout: '55%',
          plugins: {
            legend: {
              position: 'right',
              labels: {
                padding: 18,
                boxWidth: 18,
                font: {
                  size: 12,
                },
                generateLabels() {
                  return doughnutSegments.map((segment, index) => ({
                    text: segment.legendText,
                    fillStyle: doughnutColors[index],
                    strokeStyle: '#ffffff',
                    lineWidth: 2,
                    index,
                  }));
                },
              },
            },
            tooltip: {
              callbacks: {
                label: (context) => {
                  const segment = doughnutSegments[context.dataIndex];
                  return segment ? segment.tooltipText : context.label;
                },
              },
            },
          },
        },
      };

      if (charts.concentrationBreakdown) {
        charts.concentrationBreakdown.data.labels = doughnutLabels;
        charts.concentrationBreakdown.data.datasets[0].data = doughnutData;
        charts.concentrationBreakdown.data.datasets[0].backgroundColor = doughnutColors;
        charts.concentrationBreakdown.data.datasets[0].hoverBackgroundColor = doughnutHoverColors;
        charts.concentrationBreakdown.options.plugins.legend.labels.generateLabels = () =>
          doughnutSegments.map((segment, index) => ({
            text: segment.legendText,
            fillStyle: doughnutColors[index],
            strokeStyle: '#ffffff',
            lineWidth: 2,
            index,
          }));
        charts.concentrationBreakdown.options.plugins.tooltip.callbacks.label = (context) => {
          const segment = doughnutSegments[context.dataIndex];
          return segment ? segment.tooltipText : context.label;
        };
        charts.concentrationBreakdown.update();
      } else {
        charts.concentrationBreakdown = new Chart(cohortContext, cohortConfig);
      }
    }

    function buildMetaFromData() {
      const academicYears = Array.from(new Set(cache.gradeSetting.map((row) => row.year_num)))
        .filter((value) => value != null && !Number.isNaN(value))
        .sort((a, b) => a - b)
        .map((value) => formatters.toAcademicYear(value));

      const gradeLevels = Array.from(new Set(cache.gradeSetting.map((row) => row.level)))
        .filter(Boolean)
        .sort();

      const schoolTypes = Array.from(new Set(cache.gradeSetting.map((row) => row.setting))).sort();

      return {
        academicYears,
        gradeLevels,
        schoolTypes,
      };
    }

    function resetFilters() {
      Object.assign(state, {
        academicYear: 'All',
        gradeLevel: 'All',
        schoolType: 'All',
      });
      document.querySelectorAll('#controls select').forEach((select) => {
        select.value = 'All';
      });
      render();
    }

    function init() {
      fetch('dashboard/pareto_grade_setting_payload.json')
        .then((response) => response.json())
        .then((gradePayload) => {
          cache.gradeSetting = gradePayload.gradeSetting || [];

          populateControls(buildMetaFromData());
          const resetButton = document.getElementById('reset-filters');
          if (resetButton) {
            resetButton.addEventListener('click', resetFilters);
          }

          const loadingEl = document.getElementById('loading');
          if (loadingEl) {
            loadingEl.hidden = true;
          }

          const contentEl = document.getElementById('content');
          if (contentEl) {
            contentEl.hidden = false;
          }
          render();
        })
        .catch((error) => {
          console.error('Failed to load prepared data', error);
          const loadingEl = document.getElementById('loading');
          if (loadingEl) {
            loadingEl.textContent = 'Unable to load the prepared grade-setting data.';
          }
        });
    }

    updateDownloadButton(false);

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>
